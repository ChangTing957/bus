<!DOCTYPE html>
<html lang="zh-Hant">

<head>
  <meta charset="UTF-8">
  <title>毛玻璃 + Google Maps (捲簾式、可放大/收合)</title>
  <style>
    /* 讓頁面填滿視窗 */
    html,
    body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
    }

    /*
      主面板 (裝地圖)
      - 去掉底部圓角，以免看起來有「下邊一條線」。
      - 用同樣的毛玻璃效果 (rgba + backdrop-filter)。
    */
    #mainPanel {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 80%;
      height: 90%;
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.2);
      box-shadow:
        0 -5px 5px rgba(0, 0, 0, 0.5),
        /* 上 */
        5px 0 5px rgba(0, 0, 0, 0.5),
        /* 右 */
        -5px 0 5px rgba(0, 0, 0, 0.5);
      /* 左 */
      border-top-left-radius: 10px;
      border-top-right-radius: 10px;
      /* 讓底部是直角，避免多一道邊界 */
      border-bottom-left-radius: 0;
      border-bottom-right-radius: 0;

      overflow: hidden;
      z-index: 999;
      /* 地圖層級 */
    }

    /* 地圖容器 */
    #map {
      width: 100%;
      height: 100%;
      transition: transform 0.6s cubic-bezier(0.175, 0.885, 0.320, 1.275);
    }

    #mainPanel,
    #infoPanel {
      box-sizing: border-box;
      width: 70%;
    }

    /* 資訊面板初始：height=50% */
    #infoPanel {
      position: absolute;
      left: 0;
      bottom: 0;
      z-index: 1000;
      width: 100%;
      height: 50%;
      margin: 0;

      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-top-left-radius: 0;
      border-top-right-radius: 0;
      border-bottom-left-radius: 10px;
      border-bottom-right-radius: 10px;
      box-shadow:
        5px 0 5px rgba(0, 0, 0, 0.3),
        /* 右 */
        -5px 0 5px rgba(0, 0, 0, 0.3),
        /* 左 */
        0 5px 5px rgba(0, 0, 0, 0.3);
      /* 下 */
      padding: 10px;
      font-family: sans-serif;
      overflow: auto;

      /* 滑動 + 高度動畫 */
      transition: transform 0.4s ease-out, height 0.4s ease-out;
      transform: translateY(100%);
      /* 預設不顯示 (藏在下方) */
      display: none;
      /* 預設隱藏，等到打開時再切換為 block */
    }

    /* .open => 往上滑出 */
    #infoPanel.open {
      transform: translateY(0);
    }

    /* .big => 面板高度變更大 (80%) */
    #infoPanel.big {
      height: 90%;
    }

    /* 關閉按鈕 */
    #closeBtn {
      float: right;
      background: #ccc;
      border: none;
      font-weight: bold;
      cursor: pointer;
      padding: 4px 8px;
      margin-top: -6px;
      margin-right: -6px;
      border-radius: 4px;
    }

/* 分頁按鈕容器 */
.tabs {
  margin-bottom: 10px;
  display: flex;
  justify-content: flex-start;
  list-style: none;
  padding: 0;
  margin: 0;
  border-bottom: 2px solid #ddd;
}

/* 分頁按鈕 */
.tabs li {
  flex: 1;
}

.tabs button {
  width: 100%;
  padding: 6px 12px;
  margin-right: 6px;
  cursor: pointer;
  border: none;
  background-color: #f9f9f9;
  font-size: 16px;
  text-align: center;
  transition: background-color 0.3s ease;
}

.tabs button:hover {
  background-color: #e9e9e9;
}

.tabs button.active {
  background-color: #ccc;
  font-weight: bold;
  border-bottom: 2px solid #fff; /* 隱藏底邊框 */
}

/* 分頁內容 */
.tab-content {
  flex: 1; /* 撐滿剩餘空間 */
  display: flex;
  flex-direction: column;
  justify-content: flex-start; /* 內容從上方開始排列 */
  padding: 10px; /* 與左右邊距保持一致 */
  box-sizing: border-box;
  margin-bottom: auto; /* 確保下緣距離一致 */
  background-color: #f9f9f9;
  border: 1px solid #ddd;
  border-top: none;
}

/* 確保內容內的段落有適當的間距 */
.tab-content p {
  margin: 0;
  padding: 10px;
}

.tab-content.active {
  display: block;
}
  </style>
</head>

<body>
  <button onclick="findNearestFiveStops()">搜尋最近五站</button>
 
  <!-- 地圖主面板 -->
  <div id="mainPanel">
    <div id="map"></div>

    <!-- 資訊面板 -->
    <div id="infoPanel">
      <!-- 關閉按鈕 -->
      <button id="closeBtn">X</button>

      <h3 id="stationTitle">站名</h3>
<!-- 兩個按鈕做為 Tab -->
<div class="tabs">
  <button id="goBtn" class="active">去程</button>
  <button id="backBtn">回程</button>
</div>
<!-- 兩個分頁內容 -->
<div id="goContent" class="tab-content active">
  <p>去程資料</p>
</div>
<div id="backContent" class="tab-content">
  <p>回程資料</p>
</div>
</div>
  </div>

  <script>
let map;
let userMarker;
let infoWindow;
let panelOpenTime = 0;  // 紀錄面板開啟時間（毫秒）
/* 全域變數：避免重複申請 Token、快取 Route Info */
let globalTDXToken = null;
let globalTokenExpireTime = 0; // 紀錄 Token 何時到期 (毫秒時間戳)
const routeInfoCache = new Map(); // 路線資訊快取


function initMap() {
  const initialCenter = { lat: 24.1508, lng: 120.6510 };
  map = new google.maps.Map(document.getElementById("map"), {
    center: initialCenter,
    zoom: 16,
    styles: [
      { featureType: "poi", stylers: [{ visibility: "off" }] },
      { featureType: "transit.station", stylers: [{ visibility: "off" }] }
    ]
  });
  infoWindow = new google.maps.InfoWindow();

  // 綁定 Tab 切換事件
  document.getElementById('goBtn').addEventListener('click', () => showTab('go'));
  document.getElementById('backBtn').addEventListener('click', () => showTab('back'));

  // 綁定關閉按鈕事件
  document.getElementById('closeBtn').addEventListener('click', () => {
    closeInfoPanel();
  });

  // 點擊資訊面板本身則讓面板變大（展開更多資訊）
  const infoPanel = document.getElementById('infoPanel');
  infoPanel.addEventListener('click', (e) => {
    // 避免事件冒泡到 map 的 click
    e.stopPropagation();
    if (infoPanel.classList.contains('open') && !infoPanel.classList.contains('big')) {
      infoPanel.classList.add('big');
    }
  });

  // 地圖點擊事件：點擊 map (非 marker 或 infoPanel)時關閉面板
  map.addListener("click", () => {
    const infoPanel = document.getElementById('infoPanel');
    if (infoPanel.classList.contains('open')) {
      closeInfoPanel();
    }
  });

  // 全域 document click 事件：如果點擊目標不在 infoPanel 內且距離面板開啟已超過 200 毫秒，則關閉面板
  document.addEventListener('click', function(e) {
    const infoPanel = document.getElementById('infoPanel');
    if (!infoPanel.classList.contains('open')) return;
    // 若點擊發生在面板開啟後 200 毫秒內，則忽略（避免剛開啟時被關閉）
    if (Date.now() - panelOpenTime < 200) return;
    if (!infoPanel.contains(e.target)) {
      closeInfoPanel();
    }
  });

  // 確保地圖 zoom 不低於 16
  google.maps.event.addListenerOnce(map, "idle", () => {
    if (map.getZoom() < 16) {
      map.setZoom(16);
    }
  });
}

function closeInfoPanel() {
  const infoPanel = document.getElementById('infoPanel');
  infoPanel.classList.remove('big');
  infoPanel.classList.remove('open');
  setTimeout(() => {
    infoPanel.style.display = 'none';
  }, 600);
}

function showTab(tab) {
  const goBtn = document.getElementById('goBtn');
  const backBtn = document.getElementById('backBtn');
  const goContent = document.getElementById('goContent');
  const backContent = document.getElementById('backContent');

  if (tab === 'go') {
    goBtn.classList.add('active');
    backBtn.classList.remove('active');
    goContent.classList.add('active');
    backContent.classList.remove('active');
  } else {
    goBtn.classList.remove('active');
    backBtn.classList.add('active');
    goContent.classList.remove('active');
    backContent.classList.add('active');
  }
}

function getDistance(lat1, lon1, lat2, lon2) {
  const R = 6378137;
  const dLat = (lat2 - lat1) * Math.PI / 180;
  const dLon = (lon2 - lon1) * Math.PI / 180;
  const a = Math.sin(dLat / 2) ** 2 +
            Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
            Math.sin(dLon / 2) ** 2;
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
  return R * c;
}

async function handleNearestStops(userLat, userLng) {
  console.log(`使用座標：lat=${userLat}, lng=${userLng}`);

  if (userMarker) userMarker.setMap(null);
  userMarker = new google.maps.Marker({
    position: { lat: userLat, lng: userLng },
    map: map,
    title: "我的位置",
    icon: {
      path: google.maps.SymbolPath.FORWARD_CLOSED_ARROW,
      fillColor: "#4285F4",
      fillOpacity: 1,
      strokeColor: "#FFFFFF",
      strokeWeight: 2,
      scale: 6,
    },
    zIndex: 9999,
  });

  try {
    const response = await fetch("json/公車站座標.json");
    const data = await response.json();
    const stops = [];
    for (const stationName in data) {
      const stationData = data[stationName];
      let coords = null;
      if (stationData["去程"] && stationData["去程"]["經度"] && stationData["去程"]["緯度"]) {
        coords = stationData["去程"];
      } else if (stationData["回程"] && stationData["回程"]["經度"] && stationData["回程"]["緯度"]) {
        coords = stationData["回程"];
      } else {
        console.warn(`站名 "${stationName}" 缺少經緯度資訊`);
        continue;
      }
      const lat = parseFloat(coords["緯度"]);
      const lng = parseFloat(coords["經度"]);
      const dist = getDistance(userLat, userLng, lat, lng);
      stops.push({ stationName, lat, lng, distance: dist, rawData: stationData });
    }

    stops.sort((a, b) => a.distance - b.distance);
    const nearestFive = stops.slice(0, 5);
    const bounds = new google.maps.LatLngBounds();
    bounds.extend({ lat: userLat, lng: userLng });

    nearestFive.forEach((stop) => {
      const marker = new google.maps.Marker({
        position: { lat: stop.lat, lng: stop.lng },
        map: map,
        icon: "http://maps.google.com/mapfiles/ms/icons/bus.png",
      });

      marker.addListener("click", async () => {
        map.panTo(marker.getPosition());
        const infoPanel = document.getElementById('infoPanel');
        infoPanel.style.display = "block";
        infoPanel.classList.remove('big');
        void infoPanel.offsetWidth; // 強制 reflow
        infoPanel.classList.add("open");

        // 記錄開啟時間
        panelOpenTime = Date.now();

        document.getElementById('stationTitle').textContent = stop.stationName;
        try {
          const busData = await getBusArrivalTimes(stop.stationName);
          await displayBusArrivalTimes(busData);
        } catch (error) {
          console.error("取得公車到站資料時發生錯誤：", error);
          document.getElementById('goContent').innerHTML = "<p>無法取得去程資料</p>";
          document.getElementById('backContent').innerHTML = "<p>無法取得回程資料</p>";
        }
        showTab('go');
      });

      bounds.extend({ lat: stop.lat, lng: stop.lng });
    });

    map.fitBounds(bounds);
    google.maps.event.addListenerOnce(map, "idle", () => {
      if (map.getZoom() < 16) {
        map.setZoom(16);
      }
    });
  } catch (error) {
    console.error("載入或處理 JSON 時發生錯誤：", error);
  }
}

function findNearestFiveStops() {
  if (!navigator.geolocation) {
    console.error("瀏覽器不支援 geolocation。");
    return;
  }
  navigator.geolocation.getCurrentPosition(
    (pos) => {
      handleNearestStops(pos.coords.latitude, pos.coords.longitude);
    },
    (err) => {
      console.error("無法取得使用者位置：", err);
    },
    { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 }
  );
}

async function getBusArrivalTimes(stationName) {
  const clientId = 'niyangex-c9a03f8f-f658-4f40';
  const clientSecret = 'f0067ed7-d17c-422f-8306-491a54480a14';

  async function getAccessToken() {
  // 若有尚未到期的 Token，就直接用
  if (globalTDXToken && Date.now() < globalTokenExpireTime) {
    return globalTDXToken;
  }

  // 否則，重新申請
  const url = 'https://tdx.transportdata.tw/auth/realms/TDXConnect/protocol/openid-connect/token';
  const params = new URLSearchParams();
  params.append('grant_type', 'client_credentials');
  params.append('client_id', clientId);
  params.append('client_secret', clientSecret);

  const response = await fetch(url, {
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
    body: params.toString()
  });
  if (!response.ok) {
    throw new Error("取得 TDX Token 失敗: HTTP " + response.status);
  }
  const data = await response.json();
  if (!data.access_token) {
    throw new Error("取得 TDX Token 失敗: " + JSON.stringify(data));
  }

  // 記錄 Token 與過期時間 (data.expires_in 單位是秒)
  globalTDXToken = data.access_token;
  const expiresInSec = data.expires_in || 1800; // 預設 30 分鐘
  globalTokenExpireTime = Date.now() + expiresInSec * 1000;

  return globalTDXToken;
}


  try {
    const token = await getAccessToken();
    const url = `https://tdx.transportdata.tw/api/basic/v2/Bus/EstimatedTimeOfArrival/City/Taichung` +
      `?$filter=StopName/Zh_tw eq '${stationName}'&$format=JSON`;
    const response = await fetch(url, {
      headers: { 'Authorization': `Bearer ${token}` }
    });
    const data = await response.json();
    return data;
  } catch (error) {
    console.error("取得公車到站資料時發生錯誤：", error);
    throw error;
  }
}

async function getRouteInfo(routeName) {
  const clientId = 'niyangex-c9a03f8f-f658-4f40';
  const clientSecret = 'f0067ed7-d17c-422f-8306-491a54480a14';

  // 使用全域快取的 Token，避免重複請求
  async function getAccessToken() {
    if (globalTDXToken && Date.now() < globalTokenExpireTime) {
      return globalTDXToken;
    }
    const url = 'https://tdx.transportdata.tw/auth/realms/TDXConnect/protocol/openid-connect/token';
    const params = new URLSearchParams();
    params.append('grant_type', 'client_credentials');
    params.append('client_id', clientId);
    params.append('client_secret', clientSecret);
    const response = await fetch(url, {
      method: 'POST',
      headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
      body: params.toString()
    });
    if (!response.ok) {
      throw new Error("取得 TDX Token 失敗: HTTP " + response.status);
    }
    const data = await response.json();
    if (!data.access_token) {
      throw new Error("取得 TDX Token 失敗: " + JSON.stringify(data));
    }
    globalTDXToken = data.access_token;
    const expiresInSec = data.expires_in || 1800;
    globalTokenExpireTime = Date.now() + expiresInSec * 1000;
    return globalTDXToken;
  }

  try {
    const token = await getAccessToken();
    const url = `https://tdx.transportdata.tw/api/basic/v2/Bus/Route/City/Taichung?$filter=RouteName/Zh_tw eq '${routeName}'&$format=JSON`;
    const response = await fetch(url, {
      headers: { 'Authorization': `Bearer ${token}` }
    });
    const data = await response.json();
    return data[0]; // 假設只取第一筆資料
  } catch (error) {
    console.error("取得路線資料時發生錯誤：", error);
    throw error;
  }
}


/*************************************
 * 只需覆蓋以下函式：displayBusArrivalTimes
 *************************************/
 async function displayBusArrivalTimes(busData) {
  const goDiv = document.getElementById('goContent');
  const backDiv = document.getElementById('backContent');
  goDiv.innerHTML = "";
  backDiv.innerHTML = "";

  // 若無任何到站資料
  if (!Array.isArray(busData) || busData.length === 0) {
    goDiv.innerHTML = "<p>查無去程資料</p>";
    backDiv.innerHTML = "<p>查無回程資料</p>";
    return;
  }

  // 依「路線名稱」分組
  const routeMap = new Map();
  for (const item of busData) {
    const rName = item.RouteName?.Zh_tw || "未知路線";
    if (!routeMap.has(rName)) {
      routeMap.set(rName, []);
    }
    routeMap.get(rName).push(item);
  }

  // 逐條路線分別處理
  for (const [routeName, items] of routeMap.entries()) {
    // 檢查該路線是否全部都「無預估時間」
    const hasAnyTime = items.some(b => b.EstimateTime || b.EstimateTime === 0);
    let routeInfo = null;

    // 若有至少一筆有預估時間，才呼叫 getRouteInfo (減少呼叫次數)
    if (hasAnyTime) {
      // 先看快取
      if (routeInfoCache.has(routeName)) {
        routeInfo = routeInfoCache.get(routeName);
      } else {
        try {
          routeInfo = await getRouteInfo(routeName);
          routeInfoCache.set(routeName, routeInfo);
        } catch (err) {
          console.error("取得路線資訊失敗：", err);
          // 若失敗，routeInfo 依舊是 null
        }
      }
    }

    // 取得起訖站名稱，若 routeInfo = null 就給「未知起點/終點」
    const depName = routeInfo?.DepartureStopNameZh || "未知起點";
    const destName = routeInfo?.DestinationStopNameZh || "未知終點";

    // 分出去程 (Direction=0) 與回程 (Direction=1)
    const goData = items.filter(b => b.Direction === 0);
    const backData = items.filter(b => b.Direction === 1);

    // 組合「去程」
    let goHtml = "";
    if (goData.length === 0) {
      goHtml = `<p>【${routeName}】查無去程資料</p>`;
    } else {
      for (const bus of goData) {
        const t = bus.EstimateTime;
        // 預設「尚無預估時間」 => 該行文字灰色 & 不顯示終點站
        let arrivalText = "尚無預估時間";
        let styleColor = "gray";
        let showDest = false;

        if (t || t === 0) {
          // 表示有預估時間
          if (t <= 180) {
            arrivalText = (t === 0) ? "正在進站" : "即將抵達";
          } else {
            arrivalText = `${Math.floor(t / 60)} 分鐘後`;
          }
          styleColor = "black";   // 有預估時間 => 用黑色
          showDest = true;        // 顯示終點站
        }

        // 若 showDest=false => 不顯示終點站
        if (!showDest) {
          goHtml += `<p style="color:${styleColor};">路線 <b>${routeName}</b> - ${arrivalText}</p>`;
        } else {
          goHtml += `<p style="color:${styleColor};">路線 <b>${routeName}</b> 往 <b>${destName}</b> - ${arrivalText}</p>`;
        }
      }
    }

    // 組合「回程」
    let backHtml = "";
    if (backData.length === 0) {
      backHtml = `<p>【${routeName}】查無回程資料</p>`;
    } else {
      for (const bus of backData) {
        const t = bus.EstimateTime;
        let arrivalText = "尚無預估時間";
        let styleColor = "gray";
        let showDep = false;

        if (t || t === 0) {
          if (t <= 180) {
            arrivalText = (t === 0) ? "正在進站" : "即將抵達";
          } else {
            arrivalText = `${Math.floor(t / 60)} 分鐘後`;
          }
          styleColor = "black";
          showDep = true;
        }

        if (!showDep) {
          backHtml += `<p style="color:${styleColor};">路線 <b>${routeName}</b> - ${arrivalText}</p>`;
        } else {
          backHtml += `<p style="color:${styleColor};">路線 <b>${routeName}</b> 往 <b>${depName}</b> - ${arrivalText}</p>`;
        }
      }
    }

    document.getElementById('goContent').innerHTML += goHtml;
    document.getElementById('backContent').innerHTML += backHtml;
  }

  // 若最終 goDiv / backDiv 都是空 => 顯示無資料
  if (!goDiv.innerHTML) goDiv.innerHTML = "<p>查無去程資料</p>";
  if (!backDiv.innerHTML) backDiv.innerHTML = "<p>查無回程資料</p>";
}

  </script>

  <!-- 載入 Google Maps JavaScript API (替換成你的 API Key) -->
  <script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyBJnEKvcG6N6KdtutVViDu6KjHxqIa6jBI&callback=initMap"
    async defer>
    </script>
</body>

</html>